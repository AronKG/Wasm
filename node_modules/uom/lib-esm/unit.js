/* eslint-disable max-lines */
/**
 * @module Unit
 */
/**
 * Holds the dimensionless unit ONE
 * @type {Unit}
 */
export var One = createOne();
/**
 * Holds the identity converter (unique). This converter does nothing (ONE.convert(x) == x).
 * @private
 */
var identityConverter = createIdentityConverter();
/**
 * Creates a base unit having the specified symbol.
 * @param quantity The quantity of the resulting unit.
 * @param symbol The symbol of this base unit.
 */
export function createBase(name, quantity, symbol) {
    return { name: name, quantity: quantity, unitInfo: { quantity: quantity, type: "base", symbol: symbol } };
}
/**
 * Creates an alternate unit for the specified unit identified by the
 * specified symbol.
 * @param symbol The symbol for this alternate unit.
 * @param parent Parent the system unit from which this alternate unit is derived.
 */
export function createAlternate(name, symbol, parent) {
    return {
        name: name,
        quantity: parent.quantity,
        unitInfo: { quantity: parent.quantity, type: "alternate", symbol: symbol, parent: parent },
    };
}
/**
 * Returns the product of the specified units.
 * @param quantity The quantity of the resulting unit.
 * @param left The left unit operand.
 * @param right The right unit operand.</param>
 * @returns left * right
 */
export function times(name, quantity, left, right) {
    return { name: name, quantity: quantity, unitInfo: product(quantity, left, right) };
}
/**
 * Returns the quotient of the specified units.
 * @param quantity The quantity of the resulting unit.
 * @param left The dividend unit operand.
 * @param right The divisor unit operand.
 * @returns left / right
 */
export function divide(name, quantity, left, right) {
    return { name: name, quantity: quantity, unitInfo: quotient(quantity, left, right) };
}
export function squareRoot(name, quantity, unit) {
    return { name: name, quantity: quantity, unitInfo: pow(quantity, unit, 0.5) };
}
export function timesNumber(name, factor, unit) {
    return transform(name, createFactorConverter(factor), unit);
}
export function divideNumber(name, factor, unit) {
    return transform(name, createFactorConverter(1.0 / factor), unit);
}
export function plus(name, offset, unit) {
    return transform(name, createOffsetConverter(offset), unit);
}
export function minus(name, offset, unit) {
    return transform(name, createOffsetConverter(-offset), unit);
}
/**
 * Converts numeric values from a unit to another unit.
 * @param value The numeric value to convert.
 * @param fromUnit The unit from which to convert the numeric value.
 * @param toUnit The unit to which to convert the numeric value.
 * @returns The converted numeric value.
 */
export function convert(value, fromUnit, toUnit) {
    var converter = getConverter(fromUnit, toUnit);
    return convertWithConverter(value, converter);
}
export function equals(left, right) {
    return left.name === right.name;
    // if (left.unitInfo.type !== right.unitInfo.type || left.quantity !== right.quantity) {
    //   return false;
    // }
    // switch (left.unitInfo.type) {
    //   case "base":
    //     return left.unitInfo.symbol === (right.unitInfo as BaseUnit<T>).symbol;
    //   case "alternate":
    //     const alternateRight = right.unitInfo as AlternateUnit<T>;
    //     return left.unitInfo.symbol === alternateRight.symbol && equals(left.unitInfo.parent, alternateRight.parent);
    //   case "transformed":
    //     const transformedRight = right.unitInfo as TransformedUnit<T>;
    //     return (
    //       equals(left.unitInfo.parentUnit, transformedRight.parentUnit) &&
    //       unitConvertersIsEqual(left.unitInfo.toParentUnitConverter, transformedRight.toParentUnitConverter)
    //     );
    //   case "product":
    //     const productRight = right.unitInfo as ProductUnit<T>;
    //     if (left.unitInfo.elements.length !== productRight.elements.length) {
    //       return false;
    //     }
    //     return left.unitInfo.elements.every((leftElement, index) => {
    //       return (
    //         leftElement.pow === productRight.elements[index].pow &&
    //         equals(leftElement.unit, productRight.elements[index].unit)
    //       );
    //     });
    //   default:
    //     return exhaustiveCheck(left.unitInfo, true);
    // }
}
// function unitConvertersIsEqual(left: UnitConverter, right: UnitConverter): boolean {
//   if (left.type !== right.type) {
//     return false;
//   }
//   switch (left.type) {
//     case "compound":
//       const compoundRight = right as CompoundConverter;
//       return unitConvertersIsEqual(left.first, compoundRight.first);
//     case "factor":
//       const factorRight = right as FactorConverter;
//       return left.factor === factorRight.factor;
//     case "identity":
//       return true;
//     case "offset":
//       const offsetRight = right as OffsetConverter;
//       return left.offset === offsetRight.offset;
//     default:
//       return exhaustiveCheck(left, true);
//   }
// }
///////////////////////////////
/// BEGIN PRIVATE DECLARATIONS
///////////////////////////////
/**
 * @private
 */
function getConverter(fromUnit, toUnit) {
    if (equals(fromUnit, toUnit)) {
        return identityConverter;
    }
    var standardFromUnit = toStandardUnitConverter(fromUnit);
    var standardToUnit = toStandardUnitConverter(toUnit);
    return concatenateConverters(standardFromUnit, inverseConverter(standardToUnit));
}
/**
 * Returns the converter from this unit to its system unit.
 * @private
 */
function toStandardUnitConverter(unit) {
    switch (unit.unitInfo.type) {
        case "alternate":
            return toStandardUnitConverter(unit.unitInfo.parent);
        case "base":
            return identityConverter;
        case "product":
            return productUnitToStandardUnit(unit);
        case "transformed":
            return concatenateConverters(unit.unitInfo.toParentUnitConverter, toStandardUnitConverter(unit.unitInfo.parentUnit));
        default:
            return exhaustiveCheck(unit.unitInfo, true);
    }
    // throw new Error(`Unknown innerUnit ${JSON.stringify(unit)}`);
}
/**
 * Returns the unit derived from the specified unit using the specified converter.
 * The converter does not need to be linear.
 * @param operation The converter from the transformed unit to this unit.
 * @param unit The unit.
 * @returns The unit after the specified transformation.
 * @private
 */
function transform(name, operation, unit) {
    if (operation === identityConverter) {
        return unit;
    }
    return {
        name: name,
        quantity: unit.quantity,
        unitInfo: createTransformedUnit(unit, operation),
    };
}
/**
 * Creates a transformed unit from the specified parent unit.
 * @param parentUnit {Unit} The untransformed unit from which this unit is derived.
 * @param toParentUnitConverter {UnitConverter} The converter to the parent units.
 * @private
 */
function createTransformedUnit(parentUnit, toParentUnitConverter) {
    return {
        quantity: parentUnit.quantity,
        type: "transformed",
        parentUnit: parentUnit,
        toParentUnitConverter: toParentUnitConverter,
    };
}
// /**
//  * @private
//  */
// // function create<T extends string>(quantity: T, innerUnit: Unit<T>): Unit<T> {
// //   return {quantity, innerUnit}
// // }
/**
 * Creates the unit defined from the product of the specifed elements.
 * @param quantity Quantity of the resulting unit.
 * @param leftElems Left multiplicand elements.
 * @param rightElems Right multiplicand elements.
 * @private
 */
function fromProduct(quantity, leftElems, rightElems) {
    // If we have several elements of the same unit then we can merge them by summing their power
    var allElements = [];
    allElements.push.apply(allElements, leftElems);
    allElements.push.apply(allElements, rightElems);
    var resultElements = [];
    // let unitGroups: Map<Unit<any>, Array<Element>> = new Map<Unit<any>, Array<Element>>();
    // allElements.forEach((v: Element) => {
    //   const group = unitGroups.get(v.unit);
    //   if (group === undefined)
    //     unitGroups.set(v.unit, [v]);
    //   else
    //     group.push(v);
    // });
    // unitGroups.forEach((unitGroup: Array<Element>, unit: Unit<any>)=> {
    //   let sumpow: number = unitGroup.reduce((prev: number, element: Element) => prev + element.pow, 0);
    //   if (sumpow != 0) {
    //     resultElements.push(createElement(unit, sumpow));
    //   }
    // });
    var unitGroups = {};
    for (var _i = 0, allElements_1 = allElements; _i < allElements_1.length; _i++) {
        var v = allElements_1[_i];
        var group = unitGroups[JSON.stringify(v.unit)];
        if (group === undefined) {
            unitGroups[JSON.stringify(v.unit)] = [v];
        }
        else {
            group.push(v);
        }
    }
    Object.keys(unitGroups).forEach(function (unitJson) {
        var unit = JSON.parse(unitJson);
        var unitGroup = unitGroups[unitJson];
        var sumpow = unitGroup.reduce(function (prev, element) { return prev + element.pow; }, 0);
        if (sumpow !== 0) {
            resultElements.push(createElement(unit, sumpow));
        }
    });
    return createProductUnit(quantity, resultElements);
}
/**
 * @private
 */
function createElement(unit, power) {
    return { unit: unit, pow: power };
}
/**
 * @private
 */
function product(quantity, left, right) {
    var leftelements = getElements(left);
    var rightelements = getElements(right);
    return fromProduct(quantity, leftelements, rightelements);
}
/**
 * @private
 */
function quotient(quantity, left, right) {
    var leftelements = getElements(left);
    var invertedRightelements = [];
    for (var _i = 0, _a = getElements(right); _i < _a.length; _i++) {
        var element = _a[_i];
        invertedRightelements.push(createElement(element.unit, -element.pow));
    }
    return fromProduct(quantity, leftelements, invertedRightelements);
}
/**
 * @private
 */
function pow(quantity, unit, exponent) {
    var squareRootedRightelements = [];
    for (var _i = 0, _a = getElements(unit); _i < _a.length; _i++) {
        var element = _a[_i];
        squareRootedRightelements.push(createElement(element.unit, element.pow * exponent));
    }
    return fromProduct(quantity, [], squareRootedRightelements);
}
/**
 * @private
 */
function getElements(unit) {
    if (unit.unitInfo.type === "product") {
        return unit.unitInfo.elements;
    }
    else if (unit.unitInfo.type === "base" ||
        unit.unitInfo.type === "transformed" ||
        unit.unitInfo.type === "alternate") {
        // Base units has one implicit element of the unit which they describe
        return [createElement(unit, 1)];
    }
    else {
        return exhaustiveCheck(unit.unitInfo, true);
    }
}
/**
 * @private
 */
function productUnitToStandardUnit(unit) {
    var converter = identityConverter;
    for (var _i = 0, _a = getElements(unit); _i < _a.length; _i++) {
        var element = _a[_i];
        var conv = toStandardUnitConverter(element.unit);
        var power = element.pow;
        if (power < 0) {
            power = -power;
            conv = inverseConverter(conv);
        }
        for (var i = 1; i <= power; i++) {
            converter = concatenateConverters(conv, converter);
        }
    }
    return converter;
}
/**
 * @private
 */
function createProductUnit(quantity, elements) {
    return { quantity: quantity, type: "product", elements: elements };
}
/**
 * Creates a compound converter resulting from the combined
 * transformation of the specified converters.
 * @param first The first converter.
 * @param second Second the second converter.
 * @private
 */
function createCompoundConverter(first, second) {
    return { type: "compound", first: first, second: second };
}
/**
 * @private
 */
function createIdentityConverter() {
    return { type: "identity" };
}
/**
 * @private
 */
function createOffsetConverter(offset) {
    return { type: "offset", offset: offset };
}
/**
 * @private
 */
function createFactorConverter(factor) {
    if (factor === 1.0) {
        throw new Error("Argument: factor " + factor.toString());
    }
    return { type: "factor", factor: factor };
}
/**
 * Returns the inverse of this converter. If x is a valid
 * value, then x == inverse().convert(convert(x)) to within
 * the accuracy of computer arithmetic.
 * @private
 */
function inverseConverter(converter) {
    switch (converter.type) {
        case "compound":
            return createCompoundConverter(inverseConverter(converter.second), inverseConverter(converter.first));
        case "factor":
            return createFactorConverter(1.0 / converter.factor);
        case "identity":
            return converter;
        case "offset":
            return createOffsetConverter(-converter.offset);
        default:
            return exhaustiveCheck(converter, true);
    }
    // throw new Error("Unknown unit converter");
}
/**
 * @private
 */
function convertWithConverter(value, converter) {
    switch (converter.type) {
        case "compound":
            return convertWithConverter(convertWithConverter(value, converter.first), converter.second);
        case "factor":
            return value * converter.factor;
        case "identity":
            return value;
        case "offset":
            return value + converter.offset;
        default:
            return exhaustiveCheck(converter, true);
    }
    // throw new Error("Unknown unit converter");
}
/**
 * Concatenates this converter with another converter. The resulting
 * converter is equivalent to first converting by the specified converter,
 * and then converting by this converter.
 *
 * Note: Implementations must ensure that the IDENTITY instance
 *       is returned if the resulting converter is an identity
 *       converter.
 * @param concatConverter This converter.
 * @param converter The other converter.
 * @returns The concatenation of this converter with the other converter.
 * @private
 */
function concatenateConverters(concatConverter, converter) {
    return concatConverter === identityConverter
        ? converter
        : createCompoundConverter(concatConverter, converter);
}
/**
 * Used solely to create ONE instance.
 * @private
 */
function createOne() {
    return {
        name: "One",
        quantity: "Dimensionless",
        unitInfo: {
            quantity: "Dimensionless",
            type: "product",
            elements: [],
        },
    };
}
export function buildDerivedSymbol(unit, getSymbol) {
    if (getSymbol === void 0) { getSymbol = buildDerivedSymbol; }
    switch (unit.unitInfo.type) {
        case "alternate":
            return unit.unitInfo.symbol;
        case "base":
            return unit.unitInfo.symbol;
        case "product":
            return productUnitBuildDerivedName(unit, getSymbol);
        case "transformed":
            return "";
        default:
            return exhaustiveCheck(unit.unitInfo, true);
    }
    // throw new Error(`Unknown innerUnit ${JSON.stringify(unit)}`);
}
function productUnitBuildDerivedName(unit, getSymbol) {
    var comparePow = function (a, b) {
        if (a.pow > b.pow) {
            return 1;
        }
        else if (a.pow < b.pow) {
            return -1;
        }
        else {
            return 0;
        }
    };
    var pospow = getElements2(unit).filter(function (e) { return e.pow > 0; });
    pospow.sort(comparePow); // orderby e.Pow descending select e;
    var posname = productUnitBuildNameFromElements(pospow, getSymbol);
    var negpow = getElements2(unit).filter(function (e) { return e.pow < 0; });
    negpow.sort(comparePow); // orderby e.Pow ascending select e;
    var negname = productUnitBuildNameFromElements(negpow, getSymbol);
    var name = posname;
    if (negname.length > 0) {
        if (name.length === 0) {
            name += "1";
        }
        name += "/" + negname;
    }
    return name;
}
function getElements2(unit) {
    if (unit.unitInfo.type === "product") {
        return unit.unitInfo.elements;
    }
    return [];
}
function productUnitBuildNameFromElements(elements, getSymbol) {
    var name = "";
    for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {
        var e = elements_1[_i];
        name += getSymbol(e.unit);
        switch (Math.abs(e.pow)) {
            case 1:
                break;
            case 2:
                name += "²";
                break;
            case 3:
                name += "³";
                break;
            default:
                name += "^" + Math.abs(e.pow).toString();
                break;
        }
    }
    return name;
}
// See https://basarat.gitbooks.io/typescript/content/docs/types/discriminated-unions.html
// and https://github.com/Microsoft/TypeScript/issues/6155
export function exhaustiveCheck(x, throwError, match) {
    if (throwError === void 0) { throwError = false; }
    if (match === void 0) { match = ""; }
    if (throwError) {
        throw new Error("ERROR! Trying to match '" + match + "', the value " + JSON.stringify(x) + " should be of type never.");
    }
    return x;
}
//# sourceMappingURL=unit.js.map