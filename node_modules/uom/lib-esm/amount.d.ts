/**
 * @module Amount
 */
import * as Unit from "./unit";
export interface Amount<T> {
    readonly value: number;
    readonly unit: Unit.Unit<T>;
    readonly decimalCount: number;
}
export declare type Comparer = <T1, T2 extends T1>(left: Amount<T1>, right: Amount<T2>) => number;
/**
 * Default comparer
 * @param left {Amount} The left-hand amount
 * @param right {Amount} The right-hand amount
 * @returns {number} Comparer value
 */
export declare const defaultComparer: Comparer;
/**
 * Creates an amount that represents the an exact/absolute value in the specified
 * unit. For example if you create an exact amount of 2 degrees Fahrenheit that
 * will represent -16.6666667 degrees Celsius.
 * @param value {number} The numeric value of the amount.
 * @param unit {Unit<T>} The unit of the amount.
 * @param decimalCount {number | undefined} The decimalCount of the amount.
 * @returns {Amount<T>} The created amount.
 */
export declare function create<T>(value: number, unit: Unit.Unit<T>, decimalCount?: number | undefined): Amount<T>;
/**
 * Returns a string representation of an Amount.
 * @param amount {Amount} The amount.
 * @returns {string} String representation of the Amount.
 */
export declare function toString<T>(amount: Amount<T>): string;
/**
 * Negation unary operator.
 * @param amount {Amount<T>} The amount.
 */
export declare function neg<T>(amount: Amount<T>): Amount<T>;
/**
 * Determines if an Amount is of a quantity.
 * @param quantity {Quantity} Quantity to check for.
 * @param amount {Amount<T>} The amount to check.
 */
export declare function isQuantity<T>(quantity: T, amount: Amount<T>): boolean;
/**
 * Adds two amounts together.
 * The two amounts amounts must have the same quantity.
 * The resulting amount will be of the same quantity as the two amounts.
 * The resulting amount will have it's decimal count set from the
 * most granular amount.
 * @param left The left-hand amount.
 * @param right The right-hand
 * @returns left + right
 */
export declare function plus<T1, T2 extends T1>(left: Amount<T1>, right: Amount<T2>): Amount<T1>;
/**
 * Substracts two amounts from each other.
 * The two amounts amounts must have the same quantity.
 * The resulting amount will be of the same quantity as the two amounts.
 * The resulting amount will have it's decimal count set from the
 * most granular amount.
 * @param left The left-hand amount.
 * @param right The right-hand
 * @returns left + right
 */
export declare function minus<T1, T2 extends T1>(left: Amount<T1>, right: Amount<T2>): Amount<T1>;
/**
 * Multiplies an amount with a number.
 * The resulting amount has the same unit and decimal count as the original amount.
 * @param left The amount to multiply
 * @param right The number to multiply with
 */
export declare function times<T>(left: Amount<T>, right: number | Amount<Unit.Dimensionless>): Amount<T>;
/**
 * Divides an amount with a number.
 * The resulting amount has the same unit and decimal count as the original amount.
 * @param left The amount to divide
 * @param right The number to divide by
 */
export declare function divide<T>(left: Amount<T>, right: number | Amount<Unit.Dimensionless>): Amount<T>;
/**
 * Compares to amounts for equality
 * @param left {Amount} The left-hand Amount.
 * @param right {Amount} The right-hand Amount.
 * @returns {boolean} True if the amounts are equal, false otherwise.
 */
export declare function equals<T1, T2 extends T1>(left: Amount<T1>, right: Amount<T2>, comparer?: Comparer): boolean;
/**
 * Checks if one Amount is less than another.
 * @param left {Amount} The left-hand Amount.
 * @param right {Amount} The right-hand Amount.
 * @returns {boolean} True if the left-hand is less than the right-hand, false otherwise.
 */
export declare function lessThan<T1, T2 extends T1>(left: Amount<T1>, right: Amount<T2>, comparer?: Comparer): boolean;
/**
 * Checks if one Amount is greater than another.
 * @param left {Amount} The left-hand Amount.
 * @param right {Amount} The right-hand Amount.
 * @returns {boolean} True if the left-hand is less than the right-hand, false otherwise.
 */
export declare function greaterThan<T1, T2 extends T1>(left: Amount<T1>, right: Amount<T2>, comparer?: Comparer): boolean;
export declare const lessOrEqualTo: <T1, T2 extends T1>(left: Amount<T1>, right: Amount<T2>, comparer?: Comparer) => boolean;
export declare const greaterOrEqualTo: <T1, T2 extends T1>(left: Amount<T1>, right: Amount<T2>, comparer?: Comparer) => boolean;
export declare function clamp<T1, T2 extends T1>(minAmount: Amount<T1>, maxAmount: Amount<T1>, amount: Amount<T2>, comparer?: Comparer): Amount<T1>;
export declare function max<T1, T2 extends T1>(a1: Amount<T1>, a2: Amount<T2>, comparer?: Comparer): Amount<T1>;
export declare function min<T1, T2 extends T1>(a1: Amount<T1>, a2: Amount<T2>, comparer?: Comparer): Amount<T1>;
/**
 * @param step Rounding step, for example 5.0 Celsius will round 23 to 20.
 * @param amount  Amount to round.
 */
export declare function roundDown<T1, T2 extends T1>(step: Amount<T1>, amount: Amount<T2>): Amount<T1>;
/**
 * @param step Rounding step, for example 5.0 Celsius will round 23 to 25.
 * @param amount  Amount to round.
 */
export declare function roundUp<T1, T2 extends T1>(step: Amount<T1>, amount: Amount<T2>): Amount<T1>;
export declare function compareTo<T1, T2 extends T1>(left: Amount<T1>, right: Amount<T2>, comparer?: Comparer): number;
/**
 * Gets the absolute amount (equivalent of Math.Abs())
 * @param amount The amount to get the aboslute amount from.
 */
export declare function abs<T>(amount: Amount<T>): Amount<T>;
/**
 * Gets the value of the amount as a number in the specified unit
 * @param toUnit The unit to get the amount in.
 * @param amount The amount to get the value from.
 */
export declare function valueAs<T1, T2 extends T1>(toUnit: Unit.Unit<T1>, amount: Amount<T2>): number;
/**
 * Gets the most granular unit
 * For example Millimeter is more granular than Meter so in that case
 * both units should be converted to millimeter before being compared and
 * we should use the decimal count of the amount which was specified in Millimeter
 * To find which is the most granular unit, we find the difference between 1 and 2
 * in the units. The one with the highest difference is the most granular.
 * @param leftUnit
 * @param rightUnit
 * @returns The most granular unit.
 * @private
 */
export declare function getMostGranularUnit<T>(leftUnit: Unit.Unit<T>, rightUnit: Unit.Unit<T>): Unit.Unit<T>;
