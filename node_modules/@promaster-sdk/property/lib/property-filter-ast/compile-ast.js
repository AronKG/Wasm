"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.compileAst = void 0;
const CompileToString = __importStar(require("./compile-to-string"));
const exhaustive_check_1 = require("../utils/exhaustive-check");
const evaluate_ast_1 = require("./evaluate-ast");
/**
 * Compiles the AST into a callable javascript function
 * The compiled function does is an optimized version and
 * it does not support matching missing identifiers
 */
function compileAst(ast) {
    // Depending on what the property filter contains we can use different
    // compilers.
    // The fastest is to compile to a JS expression string
    // and make a function from that but it does not support:
    // * Amount values (103:Meter)
    // * Comparing name to name (a<b) (because then we don't know if they are Amount)
    // * Text values (because they require case-insensitive comparision)
    if (isNotCompilable(ast)) {
        return (properties, comparer) => evaluate_ast_1.evaluateAst(ast, properties, false, comparer);
    }
    return CompileToString.compileToString(ast);
}
exports.compileAst = compileAst;
function isNotCompilable(ast) {
    let hasAddOrMul = false;
    let hasAmountOrText = false;
    let hasNameToNameComparision = false;
    visitAllExpr(ast, (e) => {
        if (e.type === "ValueExpr" && e.parsed.type !== "integer") {
            hasAmountOrText = true;
        }
        if (e.type === "AddExpr" || e.type === "MulExpr") {
            hasAddOrMul = true;
        }
        if (e.type === "ComparisonExpr" &&
            e.leftValue.type === "IdentifierExpr" &&
            e.rightValue.type === "IdentifierExpr") {
            hasNameToNameComparision = true;
        }
        if (e.type === "EqualsExpr" &&
            e.leftValue.type === "IdentifierExpr" &&
            e.rightValueRanges.find((item) => item.min.type === "IdentifierExpr" || item.max.type === "IdentifierExpr")) {
            hasNameToNameComparision = true;
        }
    });
    return hasAddOrMul || hasAmountOrText || hasNameToNameComparision;
}
function visitAllExpr(e, visit) {
    switch (e.type) {
        case "AndExpr": {
            visit(e);
            for (const child of e.children) {
                visitAllExpr(child, visit);
            }
            return;
        }
        case "OrExpr": {
            visit(e);
            for (const child of e.children) {
                visitAllExpr(child, visit);
            }
            return;
        }
        case "EqualsExpr": {
            visit(e);
            visitAllExpr(e.leftValue, visit);
            for (const range of e.rightValueRanges) {
                visitAllExpr(range, visit);
            }
            return;
        }
        case "ValueRangeExpr": {
            visitAllExpr(e.min, visit);
            visitAllExpr(e.max, visit);
            return;
        }
        case "ComparisonExpr": {
            visit(e);
            visitAllExpr(e.leftValue, visit);
            visitAllExpr(e.rightValue, visit);
            return;
        }
        case "AddExpr": {
            visit(e);
            visitAllExpr(e.left, visit);
            visitAllExpr(e.right, visit);
            return;
        }
        case "MulExpr": {
            visit(e);
            visitAllExpr(e.left, visit);
            visitAllExpr(e.right, visit);
            return;
        }
        case "UnaryExpr": {
            visit(e);
            visitAllExpr(e.value, visit);
            return;
        }
        case "EmptyExpr":
        case "IdentifierExpr":
        case "ValueExpr":
        case "NullExpr": {
            visit(e);
            return;
        }
        default: {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any, consistent-return
            return exhaustive_check_1.exhaustiveCheck(e, true, e.type);
        }
    }
}
//# sourceMappingURL=compile-ast.js.map