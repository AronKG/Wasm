"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.equals = exports.toStringInSpecifiedOrder = exports.toString = exports.getValuesOfType = exports.map = exports.filter = exports.getInteger = exports.getText = exports.getAmount = exports.getValue = exports.removeProperty = exports.removeProperties = exports.keepProperties = exports.setText = exports.setInteger = exports.setAmount = exports.set = exports.setValues = exports.merge = exports.getPropertyNames = exports.hasProperty = exports.get = exports.count = exports.isEmpty = exports.fromProperty = exports.fromStringOrError = exports.fromString = exports.Empty = void 0;
// eslint-disable-next-line import/no-duplicates
const PropertyValue = __importStar(require("./property-value"));
exports.Empty = {};
// Functions
function fromString(encodedValueSet, unitLookup) {
    const err = () => {
        throw new Error(`${encodedValueSet} is not a valid PropertyValueSet`);
    };
    return fromStringOrError(err, encodedValueSet, unitLookup);
}
exports.fromString = fromString;
function fromStringOrError(onError, encodedValueSet, unitLookup) {
    if (!encodedValueSet || encodedValueSet.length === 0) {
        return {};
    }
    const entries = _stringToEntriesOrUndefinedIfInvalidString(encodedValueSet, unitLookup);
    if (entries === undefined) {
        return onError(encodedValueSet);
    }
    else {
        return entries;
    }
}
exports.fromStringOrError = fromStringOrError;
function fromProperty(propertyName, propertyValue) {
    return {
        [propertyName]: propertyValue,
    };
}
exports.fromProperty = fromProperty;
function isEmpty(propertyValueSet) {
    return !propertyValueSet || count(propertyValueSet) === 0;
}
exports.isEmpty = isEmpty;
function count(pvs) {
    return Object.keys(pvs).length;
}
exports.count = count;
function get(propertyName, pvs) {
    // eslint-disable-next-line no-prototype-builtins
    if (!pvs.hasOwnProperty(propertyName)) {
        return undefined;
    }
    return pvs[propertyName];
}
exports.get = get;
function hasProperty(propertyName, pvs) {
    // eslint-disable-next-line no-prototype-builtins
    return pvs.hasOwnProperty(propertyName);
}
exports.hasProperty = hasProperty;
function getPropertyNames(pvs) {
    return Object.keys(pvs);
}
exports.getPropertyNames = getPropertyNames;
function merge(mergeWith, pvs) {
    //return amend(set, mergeWith);
    return Object.assign(Object.assign({}, pvs), mergeWith);
}
exports.merge = merge;
/// If a property exists with the same name in the PropertyValueSet as in the
// replacement set then the value of that property will be replaced.
function setValues(replacementSet, pvs) {
    //return amend(set, replacementSet);
    return Object.assign(Object.assign({}, pvs), replacementSet);
}
exports.setValues = setValues;
function set(propertyName, propertyValue, pvs) {
    return amendProperty(pvs, propertyName, propertyValue);
}
exports.set = set;
function setAmount(propertyName, amountValue, pvs) {
    return amendProperty(pvs, propertyName, PropertyValue.fromAmount(amountValue));
}
exports.setAmount = setAmount;
function setInteger(propertyName, integerValue, pvs) {
    return amendProperty(pvs, propertyName, PropertyValue.fromInteger(integerValue));
}
exports.setInteger = setInteger;
function setText(propertyName, textValue, pvs) {
    return amendProperty(pvs, propertyName, PropertyValue.fromText(textValue));
}
exports.setText = setText;
/**
 * Only keep properties whos name exist in the propertyNames array
 * @param propertyNames Array of propertyNames to keep
 * @param pvs PropertyValueSet to strip unwanted properties from
 */
function keepProperties(propertyNames, pvs) {
    const newSet = {};
    for (const name of propertyNames) {
        if (pvs[name]) {
            // Don't create properties that doesn't exist
            newSet[name] = pvs[name];
        }
    }
    return newSet;
}
exports.keepProperties = keepProperties;
function removeProperties(propertyNames, pvs) {
    const newSet = {};
    for (const name of Object.keys(pvs)) {
        if (propertyNames.indexOf(name) === -1) {
            newSet[name] = pvs[name];
        }
    }
    return newSet;
}
exports.removeProperties = removeProperties;
function removeProperty(propertyName, pvs) {
    return removeProperties([propertyName], pvs);
}
exports.removeProperty = removeProperty;
/// Gets an integer value, if the value is missing the onMissing function's
/// return value is returned.
function getValue(propertyName, pvs) {
    const value = pvs[propertyName];
    return value;
}
exports.getValue = getValue;
/// Gets an amount value, if the value is missing or of the wrong type the onError function's
/// return value is returned.
function getAmount(propertyName, pvs) {
    if (!hasProperty(propertyName, pvs)) {
        return undefined;
    }
    return PropertyValue.getAmount(pvs[propertyName]);
}
exports.getAmount = getAmount;
/// Gets an integer value, if the value is missing or of the wrong type the onError function's
/// return value is returned.
function getText(propertyName, pvs) {
    if (!hasProperty(propertyName, pvs)) {
        return undefined;
    }
    return PropertyValue.getText(pvs[propertyName]);
}
exports.getText = getText;
/// Gets an integer value, if the value is missing or of the wrong type the onError function's
/// return value is returned.
function getInteger(propertyName, pvs) {
    if (!hasProperty(propertyName, pvs)) {
        return undefined;
    }
    return PropertyValue.getInteger(pvs[propertyName]);
}
exports.getInteger = getInteger;
function filter(fn, pvs) {
    const newSet = {};
    for (const name of Object.keys(pvs)) {
        if (fn({ key: name, value: pvs[name] })) {
            newSet[name] = pvs[name];
        }
    }
    return newSet;
}
exports.filter = filter;
function map(fn, pvs) {
    const newSet = {};
    for (const name of Object.keys(pvs)) {
        const map = fn({ key: name, value: pvs[name] });
        newSet[map.key] = map.value;
    }
    return newSet;
}
exports.map = map;
function getValuesOfType(type, pvs) {
    const newSet = {};
    for (const name of Object.keys(pvs)) {
        if (pvs[name].type === type) {
            newSet[name] = pvs[name];
        }
    }
    return newSet;
}
exports.getValuesOfType = getValuesOfType;
function toString(pvs) {
    return Object.keys(pvs)
        .filter((p) => pvs[p] !== null && pvs[p] !== undefined)
        .map((p) => `${p}=${PropertyValue.toString(pvs[p])}`)
        .join(";");
}
exports.toString = toString;
function toStringInSpecifiedOrder(order, pvs) {
    return order.map((p) => `${p}=${PropertyValue.toString(pvs[p])}`).join(";");
}
exports.toStringInSpecifiedOrder = toStringInSpecifiedOrder;
function equals(other, pvs, comparer = PropertyValue.defaultComparer) {
    if (other === null || other === undefined) {
        return false;
    }
    if (pvs === other) {
        return true;
    }
    if (Object.keys(pvs).length !== Object.keys(other).length) {
        return false;
    }
    for (const name of Object.keys(pvs)) {
        if (!PropertyValue.equals(other[name], pvs[name], comparer)) {
            return false;
        }
    }
    return true;
}
exports.equals = equals;
/// RULES:
/// Format should be
/// Name1=Value1;Name2=Value2;Name3=Value3
/// Values that represents strings must be enclosed in double quote (") and if they contains double quote characters they must be encoded as %22.
function _stringToEntriesOrUndefinedIfInvalidString(encodedValueSet, unitLookup) {
    const entries = {};
    // Add extra semicolon on the end to close last name/value pair
    let toParse = encodedValueSet;
    if (!toParse.endsWith(";")) {
        toParse += ";";
    }
    //StringBuffer name = new StringBuffer();
    let name = "";
    //StringBuffer value = new StringBuffer();
    let value = "";
    let isInNamePart = true;
    let isInQuote = false;
    // eslint-disable-next-line @typescript-eslint/prefer-for-of
    for (let i = 0; i < toParse.length; i++) {
        const c = toParse[i];
        switch (c) {
            case "=":
                if (!isInQuote) {
                    if (!isInNamePart) {
                        // Parse error
                        return undefined;
                    }
                    isInNamePart = false;
                }
                else {
                    value += c;
                }
                break;
            case ";":
                if (!isInQuote) {
                    if (isInNamePart) {
                        // Parse error
                        return undefined;
                    }
                    let entryValue;
                    // eslint-disable-next-line prefer-const
                    entryValue = PropertyValue.fromString(value.toString(), unitLookup);
                    //              if (!PropertyValue.TryParse(value.ToString(), out entryValue)) {
                    if (entryValue === undefined) {
                        // Parse error
                        return undefined;
                    }
                    entries[name.toString()] = entryValue;
                    isInNamePart = true;
                    //name = new StringBuffer();
                    //value = new StringBuffer();
                    name = "";
                    value = "";
                }
                else {
                    value += c;
                }
                break;
            case '"':
                isInQuote = !isInQuote;
                value += c;
                break;
            default:
                if (isInNamePart) {
                    name += c;
                }
                else {
                    value += c;
                }
                break;
        }
    }
    return entries;
}
// function amend<PropertyValueSet, T2>(obj1: PropertyValueSet, obj2: T2): PropertyValueSet {
//   // return Object.assign({}, obj1, obj2);
//   return extend(extend({}, obj1), obj2);
//   return { ...obj1, ...obj2 }
// }
function amendProperty(pvs, name, value) {
    // return amend(set, { [name]: value });
    return Object.assign(Object.assign({}, pvs), { [name]: value });
}
// function extend<TOrigin, TAdd>(origin: TOrigin, add: TAdd): TOrigin & TAdd {
//   var keys = Object.keys(add);
//   var i = keys.length;
//   while (i--) {
//     origin[keys[i]] = add[keys[i]];
//   }
//   return origin as TOrigin & TAdd;
// }
//# sourceMappingURL=property-value-set.js.map